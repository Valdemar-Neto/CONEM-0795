# -*- coding: utf-8 -*-
"""Processamento_ensaio_puncionamento.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ngvFNU0_Vd_fSKwKqOEvlScoGBUXuib2
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from matplotlib.ticker import FormatStrFormatter

"""### Ensaios puncionamento"""

fig, axes = plt.subplots(nrows=3, figsize=(10,6))

caminho1 = '/content/drive/MyDrive/Valdemar/Data_acquisition_code/Aquisicao_certo/Testes/Aceleracao/experimentos/Ensaio_aceleracao_puncionamento/ensaio_ciclo_1'
caminho2 = '/content/drive/MyDrive/Valdemar/Data_acquisition_code/Aquisicao_certo/Testes/Aceleracao/experimentos/Ensaio_aceleracao_puncionamento/ensaio_ciclo_2'
caminho3 = '/content/drive/MyDrive/Valdemar/Data_acquisition_code/Aquisicao_certo/Testes/Aceleracao/experimentos/Ensaio_aceleracao_puncionamento/ensaio_ciclo_3'
nome_coluna = ['Aceleração']

dados1 = pd.read_csv(caminho1, header= None, names = nome_coluna, delimiter = '\t')
dados1['Aceleração'] = dados1['Aceleração'].astype(str).str.replace(',', '.').astype(float)
tam1 = dados1.count()[0]
dados1['Tempo'] = np.linspace(0, tam1/2000, tam1)

dados2 = pd.read_csv(caminho2, header= None, names = nome_coluna, delimiter = '\t')
dados2['Aceleração'] = dados2['Aceleração'].astype(str).str.replace(',', '.').astype(float)
tam2 = dados2.count()[0]
dados2['Tempo'] = np.linspace(0, tam2/2000, tam2)

dados3 = pd.read_csv(caminho3, header= None, names = nome_coluna, delimiter = '\t')
dados3['Aceleração'] = dados3['Aceleração'].astype(str).str.replace(',', '.').astype(float)
tam3 = dados3.count()[0]
dados3['Tempo'] = np.linspace(0, tam3/2000, tam3)

axes[0].plot(dados1['Tempo'],
             dados1['Aceleração'])
axes[0].set_xlabel('Tempo (s)')
axes[0].set_ylabel('Aceleração (m/s²)')
axes[0].set_ylim(-15, 15)
axes[0].set_xlim(0.68, 1.68)
axes[0].grid()

axes[1].plot(dados2['Tempo'], dados2['Aceleração'])
axes[1].set_xlabel('Tempo (s)')
axes[1].set_ylabel('Aceleração (m/s²)')
axes[1].set_ylim(-15, 15)
axes[1].set_xlim(0.6, 1.6)
axes[1].grid()

axes[2].plot(dados3['Tempo'], dados3['Aceleração'])
axes[2].set_xlabel('Tempo (s)')
axes[2].set_ylabel('Aceleração (m/s²)')
axes[2].set_ylim(-15, 15)
axes[2].set_xlim(0.32, 1.32)
axes[2].grid()

plt.tight_layout()

plt.legend()
plt.show()

from scipy.signal import butter, filtfilt

dado_ciclo3 = dados3[dados3['Tempo']>0.435][dados3['Tempo']<1.32]

# Definindo a frequência de corte do filtro passa-baixa (em Hz)
frequencia_de_corte = 25
taxa_de_amostragem = 2000

# Normalizando a frequência de corte para a frequência de Nyquist
frequencia_de_corte_normalizada = frequencia_de_corte / (0.5 * taxa_de_amostragem)

#  filtro passa-baixa usando a função butter
ordem_do_filtro =   1# Ordem do filtro
b, a = butter(ordem_do_filtro, frequencia_de_corte_normalizada, btype='lowpass', analog=False)

# Aplicando o filtro passa-baixa aos dados
#dado_led1['Aceleração suavizada'] = filtfilt(b, a, dado_led1['Aceleração'])

plt.plot(dado_ciclo3['Tempo'],
         filtfilt(b, a, dado_ciclo3['Aceleração'])*1000, label = "Aceleração filtrada")

plt.plot(dado_ciclo3['Tempo'],
         dado_ciclo3['Aceleração']*1000,
         linewidth = 0.5, alpha = 0.5, label = 'Aceleração')

media = dados3[dados3['Tempo']>0.435][dados3['Tempo']<0.55].mean()

#plt.plot([0.435, 0.435], [-20, 20], 'r--')
#plt.plot([0.55, 0.55], [-20, 20], 'r--')
plt.plot([0, 5], [media[0], media[0]], 'g--')
plt.plot([0.57, 0.57], [-20, 20], 'b--', label = 'Janela Temporal')
plt.plot([1.21, 1.21], [-20, 20], 'b--')

plt.ylabel('Aceleração (mm/s²)', fontsize =12)
plt.xlabel('Tempo (s)', fontsize = 12)

plt.ylim(-25000, 25000)
plt.xlim(0.42, 1.32)

plt.grid()
plt.legend()
plt.show()

#gráfico de aceleração experimental

from scipy.signal import butter, filtfilt

dado_ciclo3 = dados3[dados3['Tempo']>0.435][dados3['Tempo']<1.32]

# Definindo a frequência de corte do filtro passa-baixa (em Hz)
frequencia_de_corte = 0.6
taxa_de_amostragem = 2000

# Normalizando a frequência de corte para a frequência de Nyquist
frequencia_de_corte_normalizada = frequencia_de_corte / (0.5 * taxa_de_amostragem)

#  filtro passa-baixa usando a função butter
ordem_do_filtro =   1# Ordem do filtro
b, a = butter(ordem_do_filtro, frequencia_de_corte_normalizada, btype='lowpass', analog=False)

# Aplicando o filtro passa-baixa aos dados
#dado_led1['Aceleração suavizada'] = filtfilt(b, a, dado_led1['Aceleração'])

plt.plot(dado_ciclo3['Tempo'],
         filtfilt(b, a, dado_ciclo3['Aceleração']))

plt.plot(dado_ciclo3['Tempo'],
         dado_ciclo3['Aceleração'],
         linewidth = 0.5, alpha = 0.5)

media = dados3[dados3['Tempo']>0.435][dados3['Tempo']<0.55].mean()

dados3['Aceleração Offset'] = dados3['Aceleração'] - media[0]

plt.plot([0.435, 0.435], [-20, 20], 'r--')
plt.plot([0.55, 0.55], [-20, 20], 'r--')
plt.plot([0, 5], [media[0], media[0]], 'g--')

plt.ylim(-1, 1)
plt.xlim(0.42, 1.32)

media2 = dados3['Aceleração Offset'][dados3['Tempo']>0.435][dados3['Tempo']<0.55].mean()
print(f'{media2:.20f}')

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt

dado_ciclo3 = dados3[dados3['Tempo']>0.59][dados3['Tempo']<1.21]

delta_t = dado_ciclo3['Tempo'].to_numpy()[-1] - dado_ciclo3['Tempo'].to_numpy()[0]
tempo = dado_ciclo3['Tempo']
aceleracao = filtfilt(b, a, dado_ciclo3['Aceleração Offset'])

velocidade_1 = np.zeros_like(aceleracao)

# Calculando a velocidade usando a regra do trapézio
for i in range(1, len(aceleracao)):
    area_trapezio = (aceleracao[i-1] + aceleracao[i]) / 2 * delta_t
    velocidade_1[i] = area_trapezio


velocidade_2 = np.zeros_like(aceleracao)

# Calculando a velocidade usando a regra de Simpson 1/3
for i in range(1, len(aceleracao)):
    area_simpson = (delta_t / 3) * (aceleracao[i-2] + 4*aceleracao[i-1] + aceleracao[i])
    velocidade_2[i] = area_simpson


velocidade_3 = np.zeros_like(aceleracao)

# Calculando a velocidade usando a regra de Simpson 3/8
for i in range(1, len(aceleracao)):
    area_simpson_38 = (3*delta_t / 8) * (aceleracao[i-3] + 3*aceleracao[i-2] + 3*aceleracao[i-1] + aceleracao[i])
    velocidade_3[i] =area_simpson_38

print(velocidade_1.max(), velocidade_2.max(), velocidade_3.max())

plt.plot(tempo, velocidade_1*1000, label = f'Método Trapézio')
plt.plot(tempo, velocidade_2*1000, label = f'Método Simpson 1/3')
plt.plot(tempo, velocidade_3*1000, label = f'Método Simpson 3/8')
plt.ylabel('Velocidade (mm/s)', fontsize = 12)
plt.xlabel('Tempo (s)', fontsize = 12)
plt.grid()
plt.legend()

plt.show()

#Três métodos de integração numérica

dado_ciclo3['Tempo'].to_numpy()[-1] - dado_ciclo3['Tempo'].to_numpy()[0]

def velocidade(r, w, theta, l):
    """
    Calcula a velociade da manivela.

    Argumentos:
    r -- Valor de r
    w -- Valor de w (omega)
    theta -- Valor do ângulo (em graus)
    l -- Valor de l

    Retorna:
    A velocidade da menivela
    """
    return -w * r * np.sin(np.deg2rad(theta)) - (w * r ** 2 * np.sin(np.deg2rad(theta)) * np.cos(np.deg2rad(theta))) / (np.sqrt(l ** 2 - r ** 2 * np.sin(np.deg2rad(theta)) ** 2))

r = 16.5  # raio
w = 114/9.5492965964254  # frequência angular
theta_values = np.linspace(0, 360,  100)  # valores de ângulo (de 0 a 360 graus)
l = 230  # comprimento

time_values = theta_values/w

velocidade_teorica = velocidade(r,w,theta_values,l)

print(velocidade_teorica.max())

tempo_intervalo_desejado = np.linspace(0.6, 1.21, len(theta_values))


plt.plot(tempo_intervalo_desejado, -velocidade_teorica, label=f'V_Teórica = {velocidade_teorica.max():.2f} ',linewidth=3, color = 'red')
plt.plot(tempo, velocidade_1*1000, label = f'Método Trapézio')
plt.plot(tempo, velocidade_2*1000, label = f'Método Simpson 1/3')
plt.plot(tempo, velocidade_3*1000, label = f'Método Simpson 3/8')
plt.ylabel('Velocidade (mm/s)', fontsize = 12)
plt.xlabel('Tempo (s)', fontsize = 12)
plt.grid()
plt.legend()

plt.show()

plt.plot(tempo_intervalo_desejado, -velocidade_teorica, label=f'V_Teórica = {velocidade_teorica.max():.2f} ',linewidth=3, color = 'red')
plt.plot(tempo, velocidade_1*1000, label = f'Método Trapézio')
plt.plot(tempo, velocidade_2*1000, label = f'Método Simpson 1/3', alpha = 0.3)
plt.plot(tempo, velocidade_3*1000, label = f'Método Simpson 3/8', alpha= 0.3)
plt.ylabel('Velocidade (mm/s)', fontsize = 12)
plt.xlabel('Tempo (s)', fontsize = 12)
plt.grid()
plt.legend()

plt.show()